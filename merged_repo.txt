$ErrorActionPreference = "Stop"
$REPO = "C:\xau_rl"
$PY   = "$REPO\.venv\Scripts\python.exe"
$LOG  = "$REPO\logs\services\mini_update_ppo.log"
$LOCK = "$REPO\logs\services\mini_update_ppo.lock"

New-Item -ItemType Directory -Force -Path (Split-Path $LOG) | Out-Null
Set-Location $REPO

# --- Lock oparty o uchwyt pliku (bez wyścigów) ---
$script:LockHandle = $null
function Acquire-Lock {
    try {
        $script:LockHandle = [System.IO.File]::Open(
            $LOCK,
            [System.IO.FileMode]::OpenOrCreate,
            [System.IO.FileAccess]::ReadWrite,
            [System.IO.FileShare]::None
        )
        return $true
    } catch { return $false }
}
function Release-Lock {
    try {
        if ($script:LockHandle) { $script:LockHandle.Close(); $script:LockHandle.Dispose(); $script:LockHandle = $null }
    } catch {}
    try { Remove-Item $LOCK -Force -ErrorAction SilentlyContinue } catch {}
}

function Run-Once {
    "`n[$(Get-Date -Format o)] [mini_update] start" | Out-File -FilePath $LOG -Append -Encoding utf8

    # --- Uruchom Pythona i zbieraj STDOUT/STDERR bez '>>' ---
    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName               = $PY
    $psi.WorkingDirectory       = $REPO
    $psi.UseShellExecute        = $false
    $psi.RedirectStandardOutput = $true
    $psi.RedirectStandardError  = $true
    $psi.CreateNoWindow         = $true
    $psi.ArgumentList.Add('-u')
    $psi.ArgumentList.Add('ops\mini_update_ppo.py')
    $psi.ArgumentList.Add('--timesteps')
    $psi.ArgumentList.Add('300000')

    $p = New-Object System.Diagnostics.Process
    $p.StartInfo = $psi

    $outHandler = {
        param($s,$e)
        if ($e.Data -ne $null) { Add-Content -LiteralPath $using:LOG -Value $e.Data -Encoding UTF8 }
    }
    $errHandler = {
        param($s,$e)
        if ($e.Data -ne $null) { Add-Content -LiteralPath $using:LOG -Value $e.Data -Encoding UTF8 }
    }

    [void]$p.Start()
    $p.add_OutputDataReceived($outHandler)
    $p.add_ErrorDataReceived($errHandler)
    $p.BeginOutputReadLine()
    $p.BeginErrorReadLine()

    $p.WaitForExit()
    $p.CancelOutputRead()
    $p.CancelErrorRead()

    $code = $p.ExitCode
    "[$(Get-Date -Format o)] [mini_update] exit_code=$code" | Out-File -FilePath $LOG -Append -Encoding utf8
    if ($code -ne 0) { throw "mini_update failed with exit_code=$code (see log)" }
    "[$(Get-Date -Format o)] [mini_update] done" | Out-File -FilePath $LOG -Append -Encoding utf8
}

while ($true) {
  try {
    if (Acquire-Lock) {
      Run-Once
      Release-Lock
    } else {
      "`n[$(Get-Date -Format o)] [mini_update] skipped (locked)" | Out-File -FilePath $LOG -Append -Encoding utf8
    }
  } catch {
    "[ERROR] $($_ | Out-String)" | Out-File -FilePath $LOG -Append -Encoding utf8
    Release-Lock
  }
  Start-Sleep -Seconds (6*3600)  # co 6h
}
