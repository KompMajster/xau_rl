# encoding: utf-8
$ErrorActionPreference = "Stop"

# === KONFIG (jak u Ciebie) ===
$REPO = "C:\xau_rl"
$PY   = "$REPO\.venv\Scripts\python.exe"
$LOG  = "$REPO\logs\services\mini_update_ppo.log"
$LOCK = "$REPO\logs\services\mini_update_ppo.lock"

New-Item -ItemType Directory -Force -Path (Split-Path $LOG) | Out-Null
Set-Location $REPO

if (-not (Test-Path -LiteralPath $PY)) { $PY = "python" }

# --- util: test zapisu do logu ---
function Test-LogWritable([string]$path, [int]$retries = 10, [int]$delayMs = 200){
    for($i=0;$i -lt $retries;$i++){
        try{
            $fs = [System.IO.File]::Open($path,
                [System.IO.FileMode]::OpenOrCreate,
                [System.IO.FileAccess]::Write,
                [System.IO.FileShare]::ReadWrite)
            $fs.Close()
            return $true
        } catch {
            Start-Sleep -Milliseconds $delayMs
        }
    }
    return $false
}

# --- Lock na uchwycie (single-run) ---
$script:LockHandle = $null
function Acquire-Lock {
    try {
        $script:LockHandle = [System.IO.File]::Open(
            $LOCK,
            [System.IO.FileMode]::OpenOrCreate,
            [System.IO.FileAccess]::ReadWrite,
            [System.IO.FileShare]::None
        ); return $true
    } catch { return $false }
}
function Release-Lock {
    try { if ($script:LockHandle){ $script:LockHandle.Close(); $script:LockHandle.Dispose(); $script:LockHandle=$null } } catch {}
    try { Remove-Item $LOCK -Force -ErrorAction SilentlyContinue } catch {}
}

function Log-Line([string]$msg){
    try { Add-Content -LiteralPath $LOG -Value $msg -Encoding UTF8 } catch {}
}

function Run-Once {
    if (-not (Test-LogWritable -path $LOG -retries 20 -delayMs 250)) {
        throw "Nie mogę uzyskać dostępu do logu: $LOG (sprawdź uprawnienia/AV/backup)."
    }

    Log-Line "`n[$(Get-Date -Format o)] [mini_update] start"

    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName               = $PY
    $psi.WorkingDirectory       = $REPO
    $psi.UseShellExecute        = $false
    $psi.RedirectStandardOutput = $true
    $psi.RedirectStandardError  = $true
    $psi.CreateNoWindow         = $true
    $psi.Arguments              = '-u "ops\mini_update_ppo.py" --timesteps 300000'

    $p = New-Object System.Diagnostics.Process
    $p.StartInfo = $psi

    # Handlery
    $outHandler = {
        param($s,$e)
        if ($e.Data -ne $null) { try { Add-Content -LiteralPath $using:LOG -Value $e.Data -Encoding UTF8 } catch {} }
    }
    $errHandler = {
        param($s,$e)
        if ($e.Data -ne $null) { try { Add-Content -LiteralPath $using:LOG -Value $e.Data -Encoding UTF8 } catch {} }
    }

    if (-not ($p.Start())) {
        throw "Nie udało się wystartować procesu: $($psi.FileName) $($psi.Arguments)"
    }

    $p.add_OutputDataReceived($outHandler)
    $p.add_ErrorDataReceived($errHandler)
    $p.BeginOutputReadLine()
    $p.BeginErrorReadLine()

    $p.WaitForExit()
    try { $p.CancelOutputRead(); $p.CancelErrorRead() } catch {}

    $code = $p.ExitCode
    Log-Line "[$(Get-Date -Format o)] [mini_update] exit_code=$code"
    if ($code -ne 0) { throw "mini_update failed with exit_code=$code (see log)" }
    Log-Line "[$(Get-Date -Format o)] [mini_update] done"
}

# --- Globalny trap: NIE pozwól wyjść z procesu bez logu ---
trap {
    try { Log-Line "[ERROR] TRAP: $($_.Exception.Message)`n$($_ | Out-String)" } catch {}
    Start-Sleep -Seconds 5
    continue
}

# === Główna pętla co 6 h ===
try {
    while ($true) {
        try {
            if (Acquire-Lock) {
                try { Run-Once } finally { Release-Lock }
            } else {
                Log-Line "`n[$(Get-Date -Format o)] [mini_update] skipped (locked)"
            }
        } catch {
            Log-Line "[ERROR] $($_.Exception.Message)`n$($_ | Out-String)"
            Release-Lock
            Start-Sleep -Seconds 5  # bezpiecznik, by nie zapętlać restartów
        }
        Start-Sleep -Seconds (6*3600)
    }
} catch {
    # Ostateczny bezpiecznik (nie powinno tu dojść)
    Log-Line "[FATAL] $($_.Exception.Message)`n$($_ | Out-String)"
    Start-Sleep -Seconds 5
    # Nie robimy 'exit'; pozwalamy NSSM zrestartować, ale zostaje ślad w logu.
}
