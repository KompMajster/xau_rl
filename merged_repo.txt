# -*- coding: utf-8 -*-
"""
Paper Trading Loop (MT5) – PPO Integration [LIVE-SAFE]
- Twarda inicjalizacja MT5 (konkretna instancja) + walidacja uprawnień.
- Cechy LIVE zgodne z treningiem: baza + LAGI (ze spec).
- Preferencja: models/features_spec_live.json (LIVE-SAFE). Fallback: features_spec.json + intersekcja.
- Obługa INVALID_STOPS: docięcie do min. dystansów brokera + fallback (open bez SL/TP -> modify SLTP).
- Normalizacja cen do 'digits', respektowanie min. odległości (trade_stops_level/distance).
- Guard: jedna instancja (lock-file), 1 pozycja per (symbol, magic), brak piramidowania, equity/hour guards.
- CSV decyzji + szczegółowe logi.

Wymaga: MetaTrader5, stable_baselines3, yaml, pandas, numpy
"""

import os
import time
import json
import pickle
import logging
from pathlib import Path
from datetime import time as dtime

import MetaTrader5 as mt5
import numpy as np
import pandas as pd
import yaml
from stable_baselines3 import PPO

# ─────────────────────────────
# Konfiguracja logów / katalogów
# ─────────────────────────────
LOG_DIR = Path("paper_demo")
LOG_DIR.mkdir(parents=True, exist_ok=True)
logging.basicConfig(
    filename=str(LOG_DIR / "live_trading.log"),
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s",
)

# ─────────────────────────────
# Czytaj config
# ─────────────────────────────
cfg = yaml.safe_load(open("config.yaml", "r", encoding="utf-8"))
SYMBOL = cfg["symbol"]
WINDOW = int(cfg.get("window", 128))
MODEL_PATH = cfg["files"]["model_path"]
VECNORM_PATH = cfg.get("files", {}).get("vecnorm_path", "models/vecnorm_xauusd_m5.pkl")

TF_MAP = {
    "M1": mt5.TIMEFRAME_M1,
    "M5": mt5.TIMEFRAME_M5,
    "M15": mt5.TIMEFRAME_M15,
}
TF_NAME = cfg.get("timeframe", "M5")
TF = TF_MAP.get(TF_NAME, mt5.TIMEFRAME_M5)

ENV = cfg.get("env", {}) or {}
MIN_EQUITY = float(ENV.get("min_equity", 0.8))     # ułamek balance
TRADE_HOURS = ENV.get("trade_hours_utc", None)     # ["06:00","20:55"] lub None
ALLOW_CLOSE_OUTSIDE = bool(ENV.get("allow_close_outside_hours", True))
SLIPPAGE_PTS = int(ENV.get("slippage", 10))
MAGIC = int(ENV.get("magic", 123456))
SLEEP_SEC = int(ENV.get("sleep_sec", 30))

# Zaawansowane – można zostawić domyślne:
SLTP_BUFFER_FACTOR = float(ENV.get("sltp_buffer_factor", 1.25))  # bufor ponad minimalny dystans
ALLOW_INLINE_STOPS = bool(ENV.get("allow_inline_stops", True))   # jeśli False → zawsze open->modify
NORMALIZE_TO_DIGITS = bool(ENV.get("normalize_to_digits", True)) # normalizuj ceny do digits

# Wymuszenie konkretnej instancji MT5
MT5_EXE = os.getenv("MT5_EXE", r"C:\Program Files\MetaTrader 5\terminal64.exe")

# Mapowanie retcode -> nazwa
RET = {
    10008: "PLACED", 10009: "DONE", 10010: "DONE_PARTIAL",
    10013: "INVALID", 10014: "INVALID_VOLUME", 10015: "INVALID_PRICE",
    10016: "INVALID_STOPS", 10017: "TRADE_DISABLED", 10018: "MARKET_CLOSED",
    10019: "NO_MONEY", 10020: "PRICE_CHANGED", 10021: "PRICE_OFF",
    10022: "INVALID_EXP", 10023: "ORDER_CHANGED", 10024: "TOO_MANY_REQUESTS",
    10025: "NO_CHANGES", 10026: "SERVER_DISABLES_AT", 10027: "CLIENT_DISABLES_AT",
    10028: "LOCKED", 10029: "FROZEN", 10030: "INVALID_FILL", 10031: "CONNECTION",
}

# ─────────────────────────────
# Helpery MT5 / środowiskowe
# ─────────────────────────────
def init_mt5(strict: bool = True):
    """Twarda inicjalizacja do konkretnej instancji MT5 + walidacja uprawnień."""
    try:
        mt5.shutdown()
    except Exception:
        pass
    if not mt5.initialize(path=MT5_EXE):
        raise RuntimeError(f"mt5.initialize() failed: {mt5.last_error()} (path={MT5_EXE})")
    ti = mt5.terminal_info()
    ai = mt5.account_info()
    logging.info(
        "MT5 init path=%s connected=%s trade_allowed=%s acc_trade_allowed=%s acc_trade_expert=%s login=%s",
        getattr(ti, "path", None), getattr(ti, "connected", None),
        getattr(ti, "trade_allowed", None), getattr(ai, "trade_allowed", None),
        getattr(ai, "trade_expert", None), getattr(ai, "login", None),
    )
    if strict:
        if not getattr(ti, "trade_allowed", False):
            raise RuntimeError("Terminal trade_allowed=False. Włącz 'Algo Trading' w MT5 albo zmień MT5_EXE.")
        if not getattr(ai, "trade_allowed", False) or not getattr(ai, "trade_expert", False):
            raise RuntimeError("Konto blokuje handel algorytmiczny (ACCOUNT_TRADE_ALLOWED/EXPERT=False).")
    return ti, ai


def in_trade_hours(ts_utc: pd.Timestamp) -> bool:
    """Czy timestamp (UTC) mieści się w oknie godzin handlu TRADE_HOURS."""
    if not TRADE_HOURS or len(TRADE_HOURS) != 2:
        return True
    try:
        sh, sm = [int(x) for x in TRADE_HOURS[0].split(":")]
        eh, em = [int(x) for x in TRADE_HOURS[1].split(":")]
        start = dtime(sh, sm); end = dtime(eh, em)
        t = ts_utc.to_pydatetime().time()
        if start <= end:
            return start <= t <= end
        return t >= start or t <= end  # okno przez północ
    except Exception:
        return True


def ensure_symbol_visible(symbol: str):
    si = mt5.symbol_info(symbol)
    if si and not si.visible:
        mt5.symbol_select(symbol, True)


def get_last_bars(symbol, timeframe, n):
    rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, n)
    if rates is None or len(rates) < n:
        return None
    df = pd.DataFrame(rates)
    df["time"] = pd.to_datetime(df["time"], unit="s", utc=True)
    if "real_volume" in df.columns:
        df.rename(columns={"real_volume": "tick_volume"}, inplace=True)
    cols = ["time", "open", "high", "low", "close", "tick_volume", "spread"]
    return df[cols]


def get_symbol_trade_constraints(symbol: str):
    """Zwraca słownik: digits, point, stops_level, stops_distance, min_dist_price."""
    info = mt5.symbol_info(symbol)
    if not info:
        return None
    digits = int(getattr(info, "digits", 2))
    point = float(getattr(info, "point", 0.01))
    stops_level = int(getattr(info, "trade_stops_level", 0))      # w punktach
    stops_distance = int(getattr(info, "trade_stops_distance", 0))# w punktach
    min_pts = max(stops_level, stops_distance)
    min_dist_price = min_pts * point
    return {
        "digits": digits,
        "point": point,
        "stops_level": stops_level,
        "stops_distance": stops_distance,
        "min_dist_price": float(min_dist_price),
    }


def normalize_price(x: float, digits: int) -> float:
    if x is None:
        return None
    if not NORMALIZE_TO_DIGITS:
        return float(x)
    return float(f"{x:.{digits}f}")


# ─────────────────────────────
# Cechy LIVE (baza + lagi)
# ─────────────────────────────
def add_features_incremental(df: pd.DataFrame) -> pd.DataFrame:
    df = df.sort_values("time").reset_index(drop=True)
    c = df["close"]
    df["ret1"] = np.log(c).diff()
    df["ema10"] = c.ewm(span=10).mean()
    df["ema50"] = c.ewm(span=50).mean()
    df["ema200"] = c.ewm(span=200).mean()
    d = c.diff()
    up = d.clip(lower=0).ewm(alpha=1/14, adjust=False).mean()
    down = (-d.clip(upper=0)).ewm(alpha=1/14, adjust=False).mean()
    rs = up / (down + 1e-12)
    df["rsi14"] = 100 - (100 / (1 + rs))
    h, l, cl = df["high"], df["low"], df["close"]
    tr = np.maximum(h - l, np.maximum((h - cl.shift()).abs(), (l - cl.shift()).abs()))
    df["atr14"] = tr.ewm(alpha=1/14, adjust=False).mean()
    ema_f = c.ewm(span=12).mean(); ema_s = c.ewm(span=26).mean()
    macd = ema_f - ema_s; sig = macd.ewm(span=9).mean()
    df["macd"] = macd; df["macd_signal"] = sig; df["macd_hist"] = macd - sig
    ma = c.rolling(20).mean(); sd = c.rolling(20).std()
    df["bb_ma"] = ma; df["bb_up"] = ma + 2*sd; df["bb_lo"] = ma - 2*sd
    df["bb_width"] = (df["bb_up"] - df["bb_lo"]) / (ma.replace(0, np.nan).abs() + 1e-12)
    df["close_log"] = np.log(c.clip(lower=1e-12))
    mu = df["close_log"].rolling(2000, min_periods=200).mean()
    s = df["close_log"].rolling(2000, min_periods=200).std().replace(0, np.nan)
    df["close_norm"] = (df["close_log"] - mu) / (s + 1e-8)
    return df.dropna().reset_index(drop=True)


def add_lags_live(df: pd.DataFrame, cols: list, max_lag: int) -> pd.DataFrame:
    if max_lag <= 0 or not cols:
        return df
    out = df
    for L in range(1, max_lag + 1):
        blk = df[cols].shift(L)
        blk.columns = [f"{c}_lag{L}" for c in cols]
        out = pd.concat([out, blk], axis=1)
    return out


def load_spec():
    """Preferuj LIVE-SAFE (features_spec_live.json); fallback: pełny spec."""
    live_p = Path("models/features_spec_live.json")
    full_p = Path("models/features_spec.json")
    if live_p.exists():
        return json.loads(live_p.read_text(encoding="utf-8")), True
    if full_p.exists():
        return json.loads(full_p.read_text(encoding="utf-8")), False
    raise RuntimeError("Brak features_spec*.json – uruchom feature discovery.")


def build_obs(df_bars: pd.DataFrame, model_obs_dim: int):
    """
    Buduje wektor obserwacji zgodnie z modelem:
    - baza + lagi do max_lag,
    - lista cech: dostępne w pierwszej kolejności, brakujące -> zera,
    - docina/podkłada blok do per_step (= (obs_dim-2)/WINDOW),
    - końcówka uzupełniona dwoma slotami (placeholdery).
    """
    spec, _ = load_spec()
    feat = add_features_incremental(df_bars)
    max_lag = int(spec.get("max_lag", 0))

    # przygotuj lagi tylko dla baz, które naprawdę występują
    base_needed = sorted({c.split("_lag")[0] for c in spec.get("feature_columns", [])})
    avail_bases = [c for c in base_needed if c in feat.columns]
    feat = add_lags_live(feat, avail_bases, max_lag)

    full_list = spec.get("feature_columns", [])
    available = [c for c in full_list if c in feat.columns]
    missing = [c for c in full_list if c not in feat.columns]
    per_step = max(1, (model_obs_dim - 2) // WINDOW)  # ile kolumn w "klocku" na krok czasu

    ordered = (available + missing)[:per_step]
    tail = feat.tail(WINDOW)
    block_cols, zero_filled = [], 0
    for col in ordered:
        if col in tail.columns:
            block_cols.append(tail[col].to_numpy(dtype=np.float32))
        else:
            block_cols.append(np.zeros(WINDOW, dtype=np.float32))
            zero_filled += 1
    while len(block_cols) < per_step:
        block_cols.append(np.zeros(WINDOW, dtype=np.float32))
        zero_filled += 1

    block = np.stack(block_cols, axis=1) if block_cols else np.zeros((WINDOW, 1), dtype=np.float32)
    flat = block.flatten()
    obs = np.concatenate([flat, np.array([0.0, 0.0], dtype=np.float32)])
    matched = len(available)
    return obs, matched, zero_filled, spec


# ─────────────────────────────
# Lot, SL/TP, zlecenia i fallback
# ─────────────────────────────
def normalize_lot(symbol, lot: float) -> float:
    info = mt5.symbol_info(symbol)
    if not info:
        return lot
    lot = max(info.volume_min, min(info.volume_max, lot))  # clamp
    steps = round(lot / info.volume_step)
    adj = steps * info.volume_step
    # format zgodnie z typowym krokiem (np. 0.01)
    return float(f"{adj:.2f}")


def dynamic_lot(equity):
    # prosta funkcja ryzyka; dostosuj do swoich preferencji
    return max(0.01, round(equity / 500000, 2))


def calc_sl_tp(price, atr):
    # ATR-owe SL/TP; jeśli atr brak -> None
    sl = price - 2 * atr if atr else None
    tp = price + 4 * atr if atr else None
    return sl, tp


def clamp_stops_to_constraints(action: int,
                               cur_bid: float, cur_ask: float,
                               sl: float, tp: float,
                               min_dist_price: float,
                               digits: int,
                               buffer_factor: float):
    """
    Koryguje SL/TP do minimalnych dystansów względem bieżącego bid/ask z buforem.
    action: 2=BUY (LONG), 0=SELL (SHORT)
    """
    buf = buffer_factor * min_dist_price
    if action == 2:  # BUY
        if sl is not None:
            sl = min(sl, cur_bid - buf)
        if tp is not None:
            tp = max(tp, cur_ask + buf)
    elif action == 0:  # SELL
        if sl is not None:
            sl = max(sl, cur_ask + buf)
        if tp is not None:
            tp = min(tp, cur_bid - buf)
    sl = normalize_price(sl, digits)
    tp = normalize_price(tp, digits)
    return sl, tp


def order_send(req: dict):
    res = mt5.order_send(req)
    code = getattr(res, "retcode", None)
    name = RET.get(code, str(code))
    try:
        logging.info("order_send retcode=%s (%s) | \n %s", code, name, res._asdict())
    except Exception:
        logging.info("order_send retcode=%s (%s)", code, name)
    return res


def modify_sl_tp(position_ticket: int, sl: float, tp: float):
    """Modyfikuje SL/TP dla istniejącej pozycji."""
    req = {
        "action": mt5.TRADE_ACTION_SLTP,
        "position": position_ticket,
        "sl": sl if sl is not None else 0.0,
        "tp": tp if tp is not None else 0.0,
        "symbol": SYMBOL,
        "magic": MAGIC,
        "comment": "Modify SLTP",
    }
    return order_send(req)


def open_market(action: int, lot: float, price: float, sl: float, tp: float, send_stops_inline: bool):
    """
    action: 2=BUY, 0=SELL.
    Jeśli send_stops_inline=True – wysyła zlecenie z SL/TP; inaczej otwiera bez SL/TP.
    """
    req = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": SYMBOL,
        "type": mt5.ORDER_TYPE_BUY if action == 2 else mt5.ORDER_TYPE_SELL,
        "volume": lot,
        "price": price,
        "deviation": SLIPPAGE_PTS,
        "magic": MAGIC,
        "comment": "Open trade",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_RETURN,
    }
    if send_stops_inline:
        if sl is not None:
            req["sl"] = sl
        if tp is not None:
            req["tp"] = tp
    res = order_send(req)
    # fallback na FOK przy INVALID_FILL:
    if getattr(res, "retcode", None) == 10030:
        req["type_filling"] = mt5.ORDER_FILLING_FOK
        res = order_send(req)
    return res


def positions_by_magic(symbol, magic):
    pos = mt5.positions_get(symbol=symbol)
    if not pos:
        return []
    return [p for p in pos if getattr(p, "magic", 0) == magic]


# ─────────────────────────────
# Główna pętla
# ─────────────────────────────
def main():
    # Lock – jedna instancja
    LOCK = LOG_DIR / "live.lock"
    if LOCK.exists():
        raise SystemExit("Inna instancja już działa (lock file).")
    LOCK.write_text(str(os.getpid()), encoding="utf-8")

    try:
        # MT5 init & symbol
        init_mt5(strict=True)
        ensure_symbol_visible(SYMBOL)

        # Model i normalizacja
        model = PPO.load(MODEL_PATH)
        expected_dim = int(model.observation_space.shape[0])

        class _IdentityVec:
            training = False
            norm_reward = False

            @staticmethod
            def normalize_obs(x):
                return x

        if Path(VECNORM_PATH).exists():
            try:
                with open(VECNORM_PATH, "rb") as f:
                    vecnorm = pickle.load(f)
                vecnorm.training = False
                vecnorm.norm_reward = False
            except Exception as e:
                logging.warning("Nie wczytano VecNormalize (%s). Używam tożsamości.", e)
                vecnorm = _IdentityVec()
        else:
            logging.info("Brak pliku VecNormalize – używam tożsamości.")
            vecnorm = _IdentityVec()

        # CSV decyzji – nagłówek
        csv = LOG_DIR / "live_decisions.csv"
        if not csv.exists():
            csv.write_text(
                "time_utc,price,action_id,action_label,equity,lot,sl,tp,retcode,retcode_name,"
                "matched_features,zero_filled,spec_id,pos_count_before,pos_count_after,reason\n",
                encoding="utf-8",
            )

        last_ts = None
        hb_t = time.time()

        while True:
            bars = get_last_bars(SYMBOL, TF, n=WINDOW + 800)
            if bars is None or len(bars) < WINDOW + 200:
                time.sleep(5)
                continue

            try:
                obs, matched, zero_filled, spec = build_obs(bars, expected_dim)
            except Exception as e:
                logging.exception("build_obs failed: %s", e)
                time.sleep(5)
                continue

            feat = add_features_incremental(bars)
            cur_ts = feat["time"].iloc[-1]

            # nie powtarzaj na tej samej świecy
            if last_ts is not None and cur_ts == last_ts:
                time.sleep(2)
                continue

            # normalizacja obserwacji
            obs_n = vecnorm.normalize_obs(obs.reshape(1, -1)).reshape(-1)
            action, _ = model.predict(obs_n, deterministic=True)
            action = int(action)
            decision = {0: "SHORT", 1: "FLAT", 2: "LONG"}.get(action, "FLAT")

            # parametry rynku i pozycji
            info = mt5.symbol_info(SYMBOL)
            if not info:
                logging.warning("Brak symbol_info – odpuszczam iterację.")
                time.sleep(SLEEP_SEC)
                continue

            tick = mt5.symbol_info_tick(SYMBOL)
            cur_bid, cur_ask = float(tick.bid), float(tick.ask)
            digits = int(getattr(info, "digits", 2))
            equity = float(mt5.account_info().equity)
            lot = normalize_lot(SYMBOL, dynamic_lot(equity))

            atr = float(feat["atr14"].iloc[-1]) if "atr14" in feat.columns else None
            # cena wejścia względem aktualnego ticka (nie z bars)
            price = cur_ask if action == 2 else cur_bid
            sl, tp = calc_sl_tp(price, atr)

            # constraints brokera
            cons = get_symbol_trade_constraints(SYMBOL) or {"min_dist_price": 0.0, "digits": digits}
            min_dist = float(cons["min_dist_price"])
            digits = int(cons.get("digits", digits))
            # skoryguj SL/TP z buforem
            sl, tp = clamp_stops_to_constraints(action, cur_bid, cur_ask, sl, tp, min_dist, digits, SLTP_BUFFER_FACTOR)
            # cena znormalizowana
            price = normalize_price(price, digits)

            # guards: equity / godziny
            pos_list = positions_by_magic(SYMBOL, MAGIC)
            pos_before = len(pos_list)
            reason = "executed"
            retcode = 10025
            retname = RET[10025]
            pos_after = pos_before

            outside_hours = not in_trade_hours(cur_ts)

            # 1) equity guard: pozwól na CLOSE, blokuj OPEN
            if equity < MIN_EQUITY * float(mt5.account_info().balance):
                if pos_before:
                    if action == 1:  # FLAT -> zamknij
                        p = pos_list[0]
                        req = {
                            "action": mt5.TRADE_ACTION_DEAL,
                            "position": p.ticket, "symbol": SYMBOL,
                            "type": mt5.ORDER_TYPE_SELL if p.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY,
                            "volume": p.volume,
                            "price": cur_bid if p.type == mt5.ORDER_TYPE_BUY else cur_ask,
                            "deviation": SLIPPAGE_PTS, "magic": MAGIC, "comment": "Close position",
                            "type_time": mt5.ORDER_TIME_GTC, "type_filling": mt5.ORDER_FILLING_RETURN,
                        }
                        res = order_send(req)
                        retcode = getattr(res, "retcode", None); retname = RET.get(retcode, str(retcode))
                        pos_after = len(positions_by_magic(SYMBOL, MAGIC))
                    else:
                        # flip – CLOSE only
                        p = pos_list[0]
                        _ = order_send({
                            "action": mt5.TRADE_ACTION_DEAL,
                            "position": p.ticket, "symbol": SYMBOL,
                            "type": mt5.ORDER_TYPE_SELL if p.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY,
                            "volume": p.volume,
                            "price": cur_bid if p.type == mt5.ORDER_TYPE_BUY else cur_ask,
                            "deviation": SLIPPAGE_PTS, "magic": MAGIC, "comment": "Close position",
                            "type_time": mt5.ORDER_TIME_GTC, "type_filling": mt5.ORDER_FILLING_RETURN,
                        })
                        reason = "equity_guard_flip_close_only"
                        pos_after = len(positions_by_magic(SYMBOL, MAGIC))
                else:
                    reason = "equity_guard_no_pos"

            # 2) poza godzinami: pozwól CLOSE, blokuj OPEN (jeśli ALLOW_CLOSE_OUTSIDE)
            elif outside_hours and ALLOW_CLOSE_OUTSIDE:
                if not pos_before:
                    reason = "outside_hours_flat_no_pos"
                else:
                    if action == 1:
                        p = pos_list[0]
                        res = order_send({
                            "action": mt5.TRADE_ACTION_DEAL,
                            "position": p.ticket, "symbol": SYMBOL,
                            "type": mt5.ORDER_TYPE_SELL if p.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY,
                            "volume": p.volume,
                            "price": cur_bid if p.type == mt5.ORDER_TYPE_BUY else cur_ask,
                            "deviation": SLIPPAGE_PTS, "magic": MAGIC, "comment": "Close position",
                            "type_time": mt5.ORDER_TIME_GTC, "type_filling": mt5.ORDER_FILLING_RETURN,
                        })
                        retcode = getattr(res, "retcode", None); retname = RET.get(retcode, str(retcode))
                        pos_after = len(positions_by_magic(SYMBOL, MAGIC))
                    else:
                        # flip po godzinach -> CLOSE only
                        p = pos_list[0]
                        _ = order_send({
                            "action": mt5.TRADE_ACTION_DEAL,
                            "position": p.ticket, "symbol": SYMBOL,
                            "type": mt5.ORDER_TYPE_SELL if p.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY,
                            "volume": p.volume,
                            "price": cur_bid if p.type == mt5.ORDER_TYPE_BUY else cur_ask,
                            "deviation": SLIPPAGE_PTS, "magic": MAGIC, "comment": "Close position",
                            "type_time": mt5.ORDER_TIME_GTC, "type_filling": mt5.ORDER_FILLING_RETURN,
                        })
                        reason = "outside_hours_flip_close_only"
                        pos_after = len(positions_by_magic(SYMBOL, MAGIC))

            # 3) w godzinach handlu → pełna polityka
            else:
                if action == 1:  # FLAT
                    if pos_before:
                        p = pos_list[0]
                        res = order_send({
                            "action": mt5.TRADE_ACTION_DEAL,
                            "position": p.ticket, "symbol": SYMBOL,
                            "type": mt5.ORDER_TYPE_SELL if p.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY,
                            "volume": p.volume,
                            "price": cur_bid if p.type == mt5.ORDER_TYPE_BUY else cur_ask,
                            "deviation": SLIPPAGE_PTS, "magic": MAGIC, "comment": "Close position",
                            "type_time": mt5.ORDER_TIME_GTC, "type_filling": mt5.ORDER_FILLING_RETURN,
                        })
                        retcode = getattr(res, "retcode", None); retname = RET.get(retcode, str(retcode))
                        pos_after = len(positions_by_magic(SYMBOL, MAGIC))
                    else:
                        reason = "flat_no_pos"
                else:
                    desired = 2 if action == 2 else 0  # LONG/SHORT
                    if not pos_before:
                        # Czy wysyłać inline SL/TP?
                        send_inline = ALLOW_INLINE_STOPS
                        # sprawdź, czy spełnia min dystanse: jeśli nie -> otwórz bez stopów
                        if min_dist > 0.0:
                            if action == 2:
                                if (sl is not None and sl >= (cur_bid - min_dist)) or \
                                   (tp is not None and tp <= (cur_ask + min_dist)):
                                    send_inline = False
                            else:
                                if (sl is not None and sl <= (cur_ask + min_dist)) or \
                                   (tp is not None and tp >= (cur_bid - min_dist)):
                                    send_inline = False

                        res = open_market(action, lot, price, sl, tp, send_inline)
                        code = getattr(res, "retcode", None)
                        # Jeśli inline odrzucony przez INVALID_STOPS – fallback: otwórz bez SL/TP
                        if code == 10016 and send_inline:
                            logging.info("Fallback: open market WITHOUT SL/TP po INVALID_STOPS.")
                            res = open_market(action, lot, price, None, None, False)
                            code = getattr(res, "retcode", None)

                        retcode = code; retname = RET.get(code, str(code))
                        pos_after = len(positions_by_magic(SYMBOL, MAGIC))

                        # Po powodzeniu – ustaw SL/TP modyfikacją
                        if retcode in (10008, 10009, 10010):
                            # pobierz świeżą pozycję
                            pls = positions_by_magic(SYMBOL, MAGIC)
                            ticket = pls[0].ticket if pls else None
                            if ticket and (sl is not None or tp is not None):
                                _ = modify_sl_tp(ticket, sl, tp)
                    else:
                        # Jest pozycja – brak piramidowania
                        p = pos_list[0]
                        same_dir = ((p.type == mt5.ORDER_TYPE_BUY and desired == 2) or
                                    (p.type == mt5.ORDER_TYPE_SELL and desired == 0))
                        if same_dir:
                            reason = "same_dir_no_pyramiding"
                        else:
                            # FLIP: zamknij i otwórz nowy kierunek
                            _ = order_send({
                                "action": mt5.TRADE_ACTION_DEAL,
                                "position": p.ticket, "symbol": SYMBOL,
                                "type": mt5.ORDER_TYPE_SELL if p.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY,
                                "volume": p.volume,
                                "price": cur_bid if p.type == mt5.ORDER_TYPE_BUY else cur_ask,
                                "deviation": SLIPPAGE_PTS, "magic": MAGIC, "comment": "Close position",
                                "type_time": mt5.ORDER_TIME_GTC, "type_filling": mt5.ORDER_FILLING_RETURN,
                            })
                            # ponownie oblicz bieżący tick i otwórz nowy
                            tick2 = mt5.symbol_info_tick(SYMBOL)
                            price2 = float(tick2.ask) if action == 2 else float(tick2.bid)
                            price2 = normalize_price(price2, digits)
                            res = open_market(action, lot, price2, sl, tp, ALLOW_INLINE_STOPS)
                            retcode = getattr(res, "retcode", None); retname = RET.get(retcode, str(retcode))
                            pos_after = len(positions_by_magic(SYMBOL, MAGIC))
                            if retcode in (10008, 10009, 10010):
                                pls = positions_by_magic(SYMBOL, MAGIC)
                                ticket = pls[0].ticket if pls else None
                                if ticket and (sl is not None or tp is not None):
                                    _ = modify_sl_tp(ticket, sl, tp)

            # zapis do CSV
            try:
                with csv.open("a", encoding="utf-8") as f:
                    f.write(
                        f"{cur_ts},{price:.5f},{action},{decision},{equity:.2f},{lot:.2f},"
                        f"{sl},{tp},{retcode},{retname},{matched},{zero_filled},"
                        f"{spec.get('spec_id','unknown')},{pos_before},{pos_after},{reason}\n"
                    )
            except Exception as e:
                logging.warning("CSV append failed: %s", e)

            last_ts = cur_ts

            # heartbeat co ~10 min
            if time.time() - hb_t > 600:
                logging.info("[HB] %s %s last_ts=%s price=%.2f pos=%d",
                             SYMBOL, TF_NAME, cur_ts, price, pos_after)
                hb_t = time.time()

            time.sleep(SLEEP_SEC)

    finally:
        try:
            mt5.shutdown()
        except Exception:
            pass
        # usuń lock-file
        try:
            (LOG_DIR / "live.lock").unlink()
        except Exception:
            pass


if __name__ == "__main__":
    main()
